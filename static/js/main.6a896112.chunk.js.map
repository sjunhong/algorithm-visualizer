{"version":3,"sources":["algorithms/helper.tsx","algorithms/BubbleSort.tsx","algorithms/InsertionSort.tsx","algorithms/MergeSort.tsx","algorithms/QuickSort.tsx","algorithms/SelectionSort.tsx","components/AlgorithmCaption.tsx","components/ColorCaption.tsx","components/Caption.tsx","components/VisualizerController.tsx","components/Navbar.tsx","components/PathfindingVisualizer/Node/Node.jsx","algorithms/dijkstra.jsx","algorithms/dfs.jsx","components/PathfindingVisualizer/PathfindingVisualizer.jsx","algorithms/bfs.jsx","components/Bar.tsx","components/SortChart.tsx","components/SortingVisualizer.tsx","components/AlgorithmVisualizer.tsx","App.tsx","reportWebVitals.ts","GlobalStyle.tsx","index.tsx"],"names":["newTrace","array","sortedIndices","searched","selected","swaped","addTrace","trace","push","getSortedIndicies","length","swap","index1","index2","temp","BubbleSort","arr","index","i","InsertionSort","traces","j","MergeSort","MergeSortHelper","start","end","middle","Math","floor","Array","keys","map","merge","leftHalf","slice","rightHalf","leftIndex","rightIndex","mainIndex","QuickSort","quickSortHelper","low","high","pivot","partition2","console","log","pivotIndex","SelectionSort","min_idx","n","Wrapper","styled","div","AlgorithmCaption","selectedAlgorithm","algorithmCaptions","timeComplexity","auxiliarySpace","caption","style","fontWeight","fontSize","alignSelf","ColorBox","p","color","CaptionWrapper","ColorCaption","colorCaption","Caption","formControlStyle","fromWidth","width","textAlign","marginLeft","menuItemStyle","menuWidth","display","height","justifyContent","alignItems","VisualizerController","props","useState","algorithm","setAlgorithm","arrayLength","setArrayLength","FormControl","margin","Select","value","onChange","e","target","handleSetAlgorithm","MenuItem","handleSetArrayLengh","Button","variant","onClick","handleResetArray","minWidth","Navbar","src","process","padding","handleToggleVisualizer","maxWidth","maxHeight","minHeight","position","left","isSorting","Node","this","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","row","extraClassName","id","className","Component","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","getAllNodes","sortNodesByDistance","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","PathfindingVisualizer","getInitialGrid","rowCount","state","ROW_COUNT","colCount","COLUMN_COUNT","initialGrid","currentRow","createNode","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","distanceToFinishNode","abs","isNode","handleMouseDown","isRunning","isGridClear","document","getElementById","setState","mousePressed","isStartNode","currRow","currCol","isFinishNode","newGrid","getNewGridWithWallToggled","isWallNode","clearGrid","nodeClassName","handleMouseEnter","handleMouseUp","handleMouseLeave","clearWalls","handleClear","visualize","algo","toggleIsRunning","nextNodesStack","currentNode","nextNode","bfs","pop","dfs","nodesInShortestPathOrder","unshift","getNodesInShortestPathOrder","animate","setTimeout","animateShortestPath","bind","ChartWrapper","onMouseLeave","rowIdx","ChartRowWrapper","nodeIdx","ButtonWrapper","ButtonStyle","newNode","attrs","$width","$height","$color","background","Bar","IsSorted","IsSearched","IsSelected","IsSwaped","genBarGraph","num","idx","includes","SortChart","SortingVisualizer","visualState","setVisualState","setTraces","timeoutIds","setTimeoutIds","isPlaying","useRef","useEffect","_reset","current","clearTimeouts","forEach","timeout","clearTimeout","timeoutArray","timeoutId","item","_changeVisualState","AlgorithmVisualizer","setIsSorting","setArray","ALGORITHMS","resetArray","random","createTraces","sorted","name","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","GlobalStyle","createGlobalStyle","normalize","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.6a896112.chunk.js","sourcesContent":["export interface Trace {\n  array: number[];\n  sortedIndices: number[];\n  searched: number[];\n  selected: number[];\n  swaped: number[];\n}\n\nexport type TraceArray = Trace[];\n\nexport const newTrace = (array: number[]): TraceArray => {\n  return [\n    {\n      array: [...array],\n      sortedIndices: [],\n      searched: [],\n      selected: [],\n      swaped: [],\n    },\n  ];\n};\n\nexport const addTrace = (\n  trace: TraceArray,\n  array: number[],\n  sortedIndices: number[] = [],\n  searched: number[] = [],\n  selected: number[] = [],\n  swaped: number[] = [],\n): void => {\n  trace.push({\n    array: [...array],\n    sortedIndices: [...sortedIndices],\n    searched: [...searched],\n    selected: [...selected],\n    swaped: [...swaped],\n  });\n};\n\nexport const getSortedIndicies = (trace: TraceArray): number[] => {\n  return trace[trace.length - 1].sortedIndices;\n};\n\n// export const getUpdatedSortedIndicies = (trace: TraceArray, targetIndex: number): number[] => {\n//   const temp = trace[trace.length - 1].sortedIndices;\n//   for (let i = 0; i < temp.length; i++) {\n//     if (temp[i] == targetIndex) {\n//       temp[i] += 1;\n//     }\n//   }\n//   return temp;\n// };\n\nexport const swap = (array: number[], index1: number, index2: number): void => {\n  const temp = array[index1];\n  array[index1] = array[index2];\n  array[index2] = temp;\n};\n","import { addTrace, getSortedIndicies, newTrace, swap, TraceArray } from './helper';\n\nexport const BubbleSort = (arr: number[]): TraceArray => {\n  const trace = newTrace(arr);\n\n  let index = arr.length - 1;\n\n  while (index > 0) {\n    for (let i = 0; i < index; i++) {\n      // visualize searching index\n      // sorted, searched, selected, swaped\n      addTrace(trace, arr, getSortedIndicies(trace), [i, i + 1]);\n\n      if (arr[i] > arr[i + 1]) {\n        addTrace(trace, arr, getSortedIndicies(trace), [], [], [i, i + 1]);\n        swap(arr, i, i + 1);\n      }\n    }\n    addTrace(trace, arr, [...getSortedIndicies(trace), index]);\n    index -= 1;\n  }\n  addTrace(trace, arr, [...getSortedIndicies(trace), index]);\n\n  return trace;\n};\n","import { addTrace, getSortedIndicies, newTrace, TraceArray } from './helper';\n\nexport const InsertionSort = (arr: number[]): TraceArray => {\n  const traces = newTrace(arr);\n  // sorted, searched, selected, swaped\n  for (let i = 0; i < arr.length; i++) {\n    addTrace(traces, arr, [...getSortedIndicies(traces), i], [], [i], []);\n    const temp = arr[i];\n    let j = i - 1;\n    while (j >= 0 && arr[j] > temp) {\n      arr[j + 1] = arr[j];\n      addTrace(traces, arr, getSortedIndicies(traces), [j + 1], [], []);\n      addTrace(traces, arr, getSortedIndicies(traces), [], [], [j, j + 1]);\n      j--;\n    }\n    arr[j + 1] = temp;\n    addTrace(traces, arr, getSortedIndicies(traces));\n  }\n\n  return traces;\n};\n","import { addTrace, getSortedIndicies, newTrace, TraceArray } from './helper';\n\nexport const MergeSort = (arr: number[]): TraceArray => {\n  const traces = newTrace(arr);\n\n  if (arr === []) {\n    return traces;\n  }\n  MergeSortHelper(traces, arr, 0, arr.length);\n  return traces;\n};\n\nconst MergeSortHelper = (traces: TraceArray, arr: number[], start: number, end: number): number[] => {\n  if (start === end - 1) {\n    return [arr[start]];\n  }\n\n  const middle = Math.floor((start + end) / 2);\n\n  MergeSortHelper(traces, arr, start, middle);\n  addTrace(\n    traces,\n    arr,\n    [...Array(middle - start).keys()].map((index: number) => index + start),\n  );\n\n  MergeSortHelper(traces, arr, middle, end);\n  addTrace(\n    traces,\n    arr,\n    [...Array(end - middle).keys()].map((index: number) => index + middle),\n  );\n\n  return merge(traces, arr, start, middle, end);\n};\n\nconst merge = (traces: TraceArray, arr: number[], start: number, middle: number, end: number): number[] => {\n  const leftHalf = arr.slice(start, middle);\n  const rightHalf = arr.slice(middle, end);\n  //reset colored sorted indices\n  addTrace(traces, arr, []);\n\n  let leftIndex = 0;\n  let rightIndex = 0;\n  let mainIndex = 0;\n  while (leftIndex < leftHalf.length && rightIndex < rightHalf.length) {\n    // addTrace(traces, arr, getSortedIndicies(traces), [], [], [start + mainIndex]);\n    addTrace(traces, arr, getSortedIndicies(traces), [], [], [start + leftIndex, middle + rightIndex]);\n\n    if (leftHalf[leftIndex] <= rightHalf[rightIndex]) {\n      arr[start + mainIndex] = leftHalf[leftIndex];\n      leftIndex += 1;\n    } else {\n      arr[start + mainIndex] = rightHalf[rightIndex];\n      rightIndex += 1;\n    }\n\n    addTrace(traces, arr, [...getSortedIndicies(traces), start + mainIndex]);\n    mainIndex += 1;\n  }\n  addTrace(traces, arr, [...getSortedIndicies(traces), start + mainIndex]);\n  while (leftIndex < leftHalf.length) {\n    // addTrace(traces, arr, getSortedIndicies(traces), [], [], [start + mainIndex]);\n    addTrace(traces, arr, getSortedIndicies(traces), [], [], [start + leftIndex]);\n\n    arr[start + mainIndex] = leftHalf[leftIndex];\n    leftIndex += 1;\n    mainIndex += 1;\n\n    addTrace(traces, arr, [...getSortedIndicies(traces), start + mainIndex]);\n  }\n  while (rightIndex < rightHalf.length) {\n    // addTrace(traces, arr, getSortedIndicies(traces), [], [], [start + mainIndex]);\n    addTrace(traces, arr, getSortedIndicies(traces), [], [], [middle + rightIndex]);\n\n    arr[start + mainIndex] = rightHalf[rightIndex];\n    rightIndex += 1;\n    mainIndex += 1;\n\n    addTrace(traces, arr, [...getSortedIndicies(traces), start + mainIndex]);\n  }\n\n  return arr.slice(start, end);\n};\n","import { addTrace, getSortedIndicies, newTrace, swap, TraceArray } from './helper';\n\nexport const QuickSort = (arr: number[]): TraceArray => {\n  const traces = newTrace(arr);\n\n  return quickSortHelper(traces, arr, 0, arr.length - 1);\n};\n\nconst quickSortHelper = (traces: TraceArray, arr: number[], low: number, high: number): TraceArray => {\n  if (low < high) {\n    const pivot = partition2(traces, arr, low, high);\n\n    console.log('call helper1', low, pivot - 1);\n    quickSortHelper(traces, arr, low, pivot - 1);\n    console.log('call helper', pivot + 1, high);\n    quickSortHelper(traces, arr, pivot + 1, high);\n  } else if (low === high) {\n    addTrace(traces, arr, [...getSortedIndicies(traces), low], [], [], []);\n  }\n  return traces;\n};\n\n// const partition1 = (traces: TraceArray, arr: number[], low: number, high: number) => {\n//   let swapIndex = low;\n//   const pivot = arr[high];\n\n//   while (low < high) {\n//     // console.log('swaping', low, high);\n//     addTrace(traces, arr, getSortedIndicies(traces), [low, swapIndex], [high]);\n//     if (arr[low] < pivot) {\n//       addTrace(traces, arr, getSortedIndicies(traces), [], [high], [low, swapIndex]);\n//       swap(arr, low, swapIndex);\n//       addTrace(traces, arr, getSortedIndicies(traces), [], [high], [low, swapIndex]);\n//       swapIndex += 1;\n//     }\n//     low += 1;\n//   }\n//   addTrace(traces, arr, getSortedIndicies(traces), [], [], [high, swapIndex]);\n//   swap(arr, swapIndex, high);\n\n//   addTrace(traces, arr, [...getSortedIndicies(traces), swapIndex], [], [], []);\n\n//   return swapIndex;\n// };\n\nconst partition2 = (traces: TraceArray, arr: number[], low: number, high: number) => {\n  const pivotIndex = high;\n  const pivot = arr[high];\n\n  while (low < high) {\n    while (low < arr.length && arr[low] < pivot) {\n      addTrace(traces, arr, getSortedIndicies(traces), [low, high], [pivotIndex]);\n      low += 1;\n    }\n    while (high > 0 && arr[high] >= pivot) {\n      addTrace(traces, arr, getSortedIndicies(traces), [low, high], [pivotIndex]);\n      high -= 1;\n    }\n\n    if (low < high) {\n      addTrace(traces, arr, getSortedIndicies(traces), [], [pivotIndex], [low, high]);\n      swap(arr, low, high);\n      addTrace(traces, arr, getSortedIndicies(traces), [], [pivotIndex], [low, high]);\n    }\n  }\n  addTrace(traces, arr, getSortedIndicies(traces), [], [], [pivotIndex, low]);\n  swap(arr, pivotIndex, low);\n  addTrace(traces, arr, [...getSortedIndicies(traces), low], [], [], []);\n\n  return low;\n};\n","import { addTrace, getSortedIndicies, newTrace, swap, TraceArray } from './helper';\n\nexport const SelectionSort = (arr: number[]): TraceArray => {\n  const trace = newTrace(arr);\n\n  let i, j, min_idx;\n  const n = arr.length;\n  for (i = 0; i < n - 1; i++) {\n    min_idx = i;\n    for (j = i + 1; j < n; j++) {\n      // visualize searching index\n      // sorted, searched, selected, swaped\n      addTrace(trace, arr, getSortedIndicies(trace), [j], [min_idx]);\n\n      if (arr[j] < arr[min_idx]) {\n        addTrace(trace, arr, getSortedIndicies(trace), [j], [min_idx]);\n\n        min_idx = j;\n\n        //visualize selected index\n        addTrace(trace, arr, getSortedIndicies(trace), [j], [min_idx]);\n      }\n    }\n\n    //visualize swaping indices\n    addTrace(trace, arr, getSortedIndicies(trace), [], [], [i, min_idx]);\n\n    swap(arr, i, min_idx);\n\n    //visualize sorted indices\n    addTrace(trace, arr, [...getSortedIndicies(trace), i]);\n  }\n\n  //visualize sorted indices\n  addTrace(trace, arr, [...getSortedIndicies(trace), n - 1]);\n\n  return trace;\n};\n","import styled from 'styled-components';\nimport { AlgorithmTypes } from './AlgorithmVisualizer';\n\ninterface AlgorithmCaptionProps {\n  selectedAlgorithm: AlgorithmTypes;\n}\n\nfunction AlgorithmCaption({ selectedAlgorithm }: AlgorithmCaptionProps): JSX.Element {\n  const algorithmCaptions = {\n    'Selection Sort': {\n      timeComplexity: 'O(n^2)',\n      auxiliarySpace: 'O(1)',\n      caption: 'Sorts by repeatedly finding the minimum element from unsorted part and putting it at the beginning',\n    },\n    'Bubble Sort': {\n      timeComplexity: 'O(n^2) worst & avg',\n      auxiliarySpace: 'O(1)',\n      caption: 'Sorts by repeatedly swapping the adjacent elements if they are in wrong order',\n    },\n    'Insertion Sort': {\n      timeComplexity: 'O(n^2)',\n      auxiliarySpace: 'O(1)',\n      caption: 'Values from the unsorted part are picked and placed at the correct position in the sorted part',\n    },\n    'Merge Sort': {\n      timeComplexity: 'O(nlogn)',\n      auxiliarySpace: 'O(n)',\n      caption:\n        'Sorts by dividing the input array into two halves, calls itself for the two halves, and then merges the two sorted halves.',\n    },\n    'Quick Sort': {\n      timeComplexity: 'O(nlogn) avg, O(n^2) worst',\n      auxiliarySpace: 'O(1)',\n      caption: 'Sorts by picking an element as pivot and partitions the given array around the picked pivot',\n    },\n  };\n  return (\n    <Wrapper>\n      <div style={{ fontWeight: 600, fontSize: '1.8vw', alignSelf: 'center' }}>{selectedAlgorithm}</div>\n      <div>\n        <span>Time Complexity: </span> {algorithmCaptions[selectedAlgorithm].timeComplexity}\n      </div>\n      <div>\n        <span>Auxiliary Space: </span> {algorithmCaptions[selectedAlgorithm].auxiliarySpace}\n      </div>\n      <div>{algorithmCaptions[selectedAlgorithm].caption}</div>\n    </Wrapper>\n  );\n}\n\nconst Wrapper = styled.div`\n  display: flex;\n  flex-direction: column;\n  width: 50vw;\n  align-items: start;\n  justify-content: space-between;\n  padding: 0 5vw 0 5vw;\n\n  div {\n    font-size: 1.4vw;\n    padding-top: 0.2vw;\n  }\n\n  span {\n    font-size: 1.4vw;\n    font-weight: 500;\n    padding-left: 9vw;\n  }\n`;\n\nexport default AlgorithmCaption;\n","import styled from 'styled-components';\n\nfunction ColorCaption(): JSX.Element {\n  const colorCaptions = [\n    {\n      color: '#06D6A0',\n      caption: 'SORTED',\n    },\n    {\n      color: '#D81159',\n      caption: 'SWAPING',\n    },\n    {\n      color: '#FFD166',\n      caption: 'SELECTED',\n    },\n    {\n      color: '#118AB2',\n      caption: 'SEARCHING',\n    },\n  ];\n  return (\n    <Wrapper>\n      {colorCaptions.map((colorCaption) => (\n        <CaptionWrapper key={colorCaption.color}>\n          <ColorBox color={colorCaption.color}></ColorBox>\n          {colorCaption.caption}\n        </CaptionWrapper>\n      ))}\n    </Wrapper>\n  );\n}\n\nconst ColorBox = styled.div<{ color: string }>`\n  width: 4vw;\n  height: 3vh;\n  margin: 0 1vw 0 0;\n  background: ${(p) => p.color};\n  border-radius: 5px;\n  border: 1px solid rgba(0, 0, 0, 0.2);\n`;\n\nconst CaptionWrapper = styled.div`\n  display: flex;\n  justify-content: start;\n  align-items: center;\n  padding: 0.5vw;\n  font-size: 1.5vw;\n`;\n\nconst Wrapper = styled.div`\n  display: grid;\n  grid-template-columns: 1fr 1fr;\n  justify-content: start;\n  align-items: start;\n  padding: 1vw 2vw 0 4vw;\n  width: 50vw;\n`;\n\nexport default ColorCaption;\n","import styled from 'styled-components';\nimport AlgorithmCaption from './AlgorithmCaption';\nimport { AlgorithmTypes } from './AlgorithmVisualizer';\nimport ColorCaption from './ColorCaption';\n\ninterface CaptionProps {\n  selectedAlgorithm: AlgorithmTypes;\n}\n\nfunction Caption({ selectedAlgorithm }: CaptionProps): JSX.Element {\n  return (\n    <Wrapper>\n      <ColorCaption />\n      <AlgorithmCaption selectedAlgorithm={selectedAlgorithm} />\n    </Wrapper>\n  );\n}\n\nconst Wrapper = styled.div`\n  display: flex;\n  width: 100vw;\n`;\n\nexport default Caption;\n","import { Button, FormControl, MenuItem, Select } from '@material-ui/core';\nimport { useState } from 'react';\nimport styled from 'styled-components';\nimport { AlgorithmTypes } from './AlgorithmVisualizer';\n\ninterface VisualizerControllerProps {\n  handleResetArray: () => void;\n  handleSetAlgorithm: (name: AlgorithmTypes) => void;\n  handleSetArrayLengh: (arrayLength: number) => void;\n}\n\nfunction VisualizerController(props: VisualizerControllerProps): JSX.Element {\n  const [algorithm, setAlgorithm] = useState<string>('Selection Sort');\n  const [arrayLength, setArrayLength] = useState<number>(100);\n  const algorithms = ['Selection Sort', 'Bubble Sort', 'Insertion Sort', 'Merge Sort', 'Quick Sort'];\n  const arrayLengths = [10, 50, 100, 200];\n  return (\n    <Wrapper>\n      <FormControl margin=\"none\">\n        <Select\n          value={algorithm}\n          onChange={(e) => {\n            setAlgorithm(e.target.value as string);\n            props.handleSetAlgorithm(e.target.value as AlgorithmTypes);\n          }}\n          style={formControlStyle('17vw')}\n        >\n          {algorithms.map((algorithm) => (\n            <MenuItem key={algorithm} value={algorithm}>\n              <span style={menuItemStyle('17vw')}>{algorithm}</span>\n            </MenuItem>\n          ))}\n        </Select>\n      </FormControl>\n      <FormControl margin=\"none\">\n        <Select\n          value={arrayLength}\n          onChange={(e) => {\n            setArrayLength(e.target.value as number);\n            props.handleSetArrayLengh(e.target.value as number);\n          }}\n          style={formControlStyle('10vw')}\n        >\n          {arrayLengths.map((arrayLength) => (\n            <MenuItem key={arrayLength} value={arrayLength}>\n              <span style={menuItemStyle('10vw')}>{arrayLength}</span>\n            </MenuItem>\n          ))}\n        </Select>\n      </FormControl>\n      <Button variant=\"contained\" onClick={props.handleResetArray} style={{ minWidth: '8vw', marginLeft: '1.5vw' }}>\n        <span>Reset</span>\n      </Button>\n    </Wrapper>\n  );\n}\n\nconst formControlStyle = (fromWidth: string): React.CSSProperties => {\n  return { width: fromWidth, textAlign: 'center', fontWeight: 500, marginLeft: '1.5vw' };\n};\n\nconst menuItemStyle = (menuWidth: string): React.CSSProperties => {\n  return {\n    display: 'flex',\n    width: menuWidth,\n    height: '6vh',\n    justifyContent: 'center',\n    alignItems: 'center',\n    fontWeight: 500,\n  };\n};\n\nconst Wrapper = styled.div`\n  display: flex;\n  justify-content: flex-end;\n  align-items: center;\n  width: 45vw;\n  margin: 0 2.5% 0 0;\n`;\n\nexport default VisualizerController;\n","import { Button } from '@material-ui/core';\nimport styled from 'styled-components';\nimport { AlgorithmTypes } from './AlgorithmVisualizer';\nimport VisualizerController from './VisualizerController';\n\ninterface NavbarProps {\n  handleResetArray: () => void;\n  handleSetAlgorithm: (name: AlgorithmTypes) => void;\n  handleSetArrayLengh: (arrayLength: number) => void;\n  handleToggleVisualizer: () => void;\n  isSorting: boolean;\n}\n\nfunction Navbar(props: NavbarProps): JSX.Element {\n  return (\n    <Wrapper>\n      <img\n        src={`${process.env.PUBLIC_URL}/logo_for_kiosk.svg`}\n        style={{ width: '40vw', height: '10vh', padding: '0.1vw 0 0 0' }}\n      />\n      <Button\n        variant=\"outlined\"\n        color=\"secondary\"\n        onClick={props.handleToggleVisualizer}\n        style={{\n          maxWidth: '9vw',\n          minWidth: '9vw',\n          maxHeight: '5.5vh',\n          minHeight: '5.5vh',\n          position: 'absolute',\n          left: 'calc(50vw - 4.5vw)',\n        }}\n      >\n        {props.isSorting ? <span>Graph</span> : <span>Sorting</span>}\n      </Button>\n      {props.isSorting ? (\n        <VisualizerController\n          handleResetArray={props.handleResetArray}\n          handleSetAlgorithm={props.handleSetAlgorithm}\n          handleSetArrayLengh={props.handleSetArrayLengh}\n        />\n      ) : (\n        <></>\n      )}\n    </Wrapper>\n  );\n}\n\nconst Wrapper = styled.div`\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  width: 100vw;\n  height: 10%;\n  background: white;\n`;\n\nexport default Navbar;\n","/* eslint-disable react/prop-types */\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-nocheck\n\nimport React, {Component} from 'react';\n\nimport './Node.css';\n\nexport default class Node extends Component {\n  render() {\n    const {\n      col,\n      isFinish,\n      isStart,\n      isWall,\n      onMouseDown,\n      onMouseEnter,\n      onMouseUp,\n      row,\n    } = this.props;\n    \n    const extraClassName = isFinish\n      ? 'node-finish'\n      : isStart\n      ? 'node-start'\n      : isWall\n      ? 'node-wall'\n      : '';\n\n    return (\n      <td\n        id={`node-${row}-${col}`}\n        className={`node ${extraClassName}`}\n        onMouseDown={() => onMouseDown(row, col)}\n        onMouseEnter={() => onMouseEnter(row, col)}\n        onMouseUp={() => onMouseUp()}></td>\n    );\n  }\n}","// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-nocheck\n\nexport const dijkstra = (grid, startNode, finishNode) => {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid); // Q: different from using grid or slice of grid???\n\n  while (unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (!closestNode.isWall) {\n      // If the closest node is at a distance of infinity,\n      // we must be trapped and should stop.\n      if (closestNode.distance === Infinity) return visitedNodesInOrder;\n      closestNode.isVisited = true;\n      visitedNodesInOrder.push(closestNode);\n      if (closestNode === finishNode) return visitedNodesInOrder;\n      updateUnvisitedNeighbors(closestNode, grid);\n    }\n  }\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\n}\n","// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-nocheck\n\nexport const dfs = (grid, startNode, finishNode) => {\n  const visitedNodesInOrder = [];\n  const nextNodesStack = [];\n  nextNodesStack.push(startNode);\n  while (nextNodesStack.length) {\n    const currentNode = nextNodesStack.pop();\n\n    if (currentNode === finishNode) {\n      return visitedNodesInOrder;\n    }\n\n    if (!currentNode.isWall && (currentNode.isStart || !currentNode.isVisited)) {\n      currentNode.isVisited = true;\n      visitedNodesInOrder.push(currentNode);\n\n      const { col, row } = currentNode;\n      let nextNode;\n      if (row > 0) {\n        nextNode = grid[row - 1][col];\n        if (!nextNode.isVisited) {\n          nextNode.previousNode = currentNode;\n          nextNodesStack.push(nextNode);\n        }\n      }\n      if (row < grid.length - 1) {\n        nextNode = grid[row + 1][col];\n        if (!nextNode.isVisited) {\n          nextNode.previousNode = currentNode;\n          nextNodesStack.push(nextNode);\n        }\n      }\n      if (col > 0) {\n        nextNode = grid[row][col - 1];\n        if (!nextNode.isVisited) {\n          nextNode.previousNode = currentNode;\n          nextNodesStack.push(nextNode);\n        }\n      }\n      if (col < grid[0].length - 1) {\n        nextNode = grid[row][col + 1];\n        if (!nextNode.isVisited) {\n          nextNode.previousNode = currentNode;\n          nextNodesStack.push(nextNode);\n        }\n      }\n    }\n  }\n}\n","// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-nocheck\n\nimport React, { Component } from 'react';\nimport Node from './Node/Node';\nimport { dijkstra } from '../../algorithms/dijkstra';\nimport { dfs } from '../../algorithms/dfs';\nimport { bfs } from '../../algorithms/bfs';\nimport styled from 'styled-components';\nimport { Button } from '@material-ui/core';\n\n\nexport default class PathfindingVisualizer extends Component {\n  constructor() {\n    super();\n    this.state = {\n      grid: [],\n      START_NODE_ROW: 5,\n      START_NODE_COL: 5,\n      FINISH_NODE_ROW: 19,\n      FINISH_NODE_COL: 29,\n      mousePressed: false,\n      ROW_COUNT: 25,\n      COLUMN_COUNT: 35,\n      isRunning: false,\n      isStartNode: false,\n      isFinishNode: false,\n      isWallNode: false, \n      currRow: 0,\n      currCol: 0,\n    };\n\n    this.handleMouseDown = this.handleMouseDown.bind(this);\n    this.handleMouseLeave = this.handleMouseLeave.bind(this);\n    this.toggleIsRunning = this.toggleIsRunning.bind(this);\n  }\n\n  componentDidMount() {\n    const grid = this.getInitialGrid();\n    this.setState({ grid });\n  }\n\n  toggleIsRunning() {\n    this.setState({ isRunning: !this.state.isRunning });\n  }\n\n\n  getInitialGrid = (rowCount = this.state.ROW_COUNT, colCount = this.state.COLUMN_COUNT) => {\n    const initialGrid = [];\n\n    for (let row = 0; row < rowCount; row++) {\n      const currentRow = [];\n      for (let col = 0; col < colCount; col++) {\n        currentRow.push(this.createNode(row, col));\n      }\n      initialGrid.push(currentRow);\n    }\n    return initialGrid;\n  };\n\n  createNode = (row, col) => {\n    return {\n      row,\n      col,\n      isStart: row === this.state.START_NODE_ROW && col === this.state.START_NODE_COL,\n      isFinish: row === this.state.FINISH_NODE_ROW && col === this.state.FINISH_NODE_COL,\n      distance: Infinity,\n      distanceToFinishNode: Math.abs(this.state.FINISH_NODE_ROW - row) + Math.abs(this.state.FINISH_NODE_COL - col),\n      isVisited: false,\n      isWall: false,\n      previousNode: null,\n      isNode: true,\n    };\n  };\n\n  handleMouseDown = (row, col) => {\n    if (!this.state.isRunning) {\n      if (this.isGridClear()) {\n        if (document.getElementById(`node-${row}-${col}`).className === 'node node-start') {\n          this.setState({\n            mousePressed: true,\n            isStartNode: true,\n            currRow: row,\n            currCol: col,\n          });\n        } else if (document.getElementById(`node-${row}-${col}`).className === 'node node-finish') {\n          this.setState({\n            mousePressed: true,\n            isFinishNode: true,\n            currRow: row,\n            currCol: col,\n          });\n        } else {\n          const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n          this.setState({\n            grid: newGrid,\n            mousePressed: true,\n            isWallNode: true,\n            currRow: row,\n            currCol: col,\n          });\n        }\n      } else {\n        this.clearGrid();\n      }\n    }\n  }\n\n  isGridClear = () => {\n    for (const row of this.state.grid) {\n      for (const node of row) {\n        const nodeClassName = document.getElementById(`node-${node.row}-${node.col}`).className;\n        if (nodeClassName === 'node node-visited' || nodeClassName === 'node node-shortest-path') {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  handleMouseEnter = (row, col) => {\n    if (!this.state.isRunning) {\n      if (this.state.mousePressed) {\n        const nodeClassName = document.getElementById(`node-${row}-${col}`).className;\n        if (this.state.isStartNode) {\n          if (nodeClassName !== 'node node-wall') {\n            const prevStartNode = this.state.grid[this.state.currRow][this.state.currCol];\n            prevStartNode.isStart = false;\n            document.getElementById(`node-${this.state.currRow}-${this.state.currCol}`).className = 'node';\n\n            this.setState({ currRow: row, currCol: col });\n\n            const currStartNode = this.state.grid[row][col];\n            currStartNode.isStart = true;\n            document.getElementById(`node-${row}-${col}`).className = 'node node-start';\n          }\n          this.setState({ START_NODE_ROW: row, START_NODE_COL: col });\n        } else if (this.state.isFinishNode) {\n          if (nodeClassName !== 'node node-wall') {\n            const prevFinishNode = this.state.grid[this.state.currRow][this.state.currCol];\n            prevFinishNode.isFinish = false;\n            document.getElementById(`node-${this.state.currRow}-${this.state.currCol}`).className = 'node';\n\n            this.setState({ currRow: row, currCol: col });\n\n            const currFinishNode = this.state.grid[row][col];\n            currFinishNode.isFinish = true;\n            document.getElementById(`node-${row}-${col}`).className = 'node node-finish';\n          }\n          this.setState({ FINISH_NODE_ROW: row, FINISH_NODE_COL: col });\n        } else if (this.state.isWallNode) {\n          const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n          this.setState({ grid: newGrid });\n        }\n      }\n    }\n  }\n\n  handleMouseUp = (row, col) => {\n    if (!this.state.isRunning) {\n      this.setState({ mousePressed: false });\n      \n      if (this.state.isStartNode) {\n        const isStartNode = !this.state.isStartNode;\n        this.setState({ isStartNode, START_NODE_ROW: row, START_NODE_COL: col });\n      } else if (this.state.isFinishNode) {\n        const isFinishNode = !this.state.isFinishNode;\n        this.setState({\n          isFinishNode,\n          FINISH_NODE_ROW: row,\n          FINISH_NODE_COL: col,\n        });\n      }\n      this.getInitialGrid();\n    }\n  }\n\n  handleMouseLeave = () => {\n    if (this.state.isStartNode) {\n      const isStartNode = !this.state.isStartNode;\n      this.setState({ isStartNode, mousePressed: false });\n    } else if (this.state.isFinishNode) {\n      const isFinishNode = !this.state.isFinishNode;\n      this.setState({ isFinishNode, mousePressed: false });\n    } else if (this.state.isWallNode) {\n      const isWallNode = !this.state.isWallNode;\n      this.setState({ isWallNode, mousePressed: false });\n      this.getInitialGrid();\n    }\n  }\n\n  clearGrid = () => {\n    if (!this.state.isRunning) {\n      const newGrid = this.state.grid.slice();\n\n      for (const row of newGrid) {\n        for (const node of row) {\n          let nodeClassName = document.getElementById(`node-${node.row}-${node.col}`).className;\n\n          if (\n            nodeClassName !== 'node node-start' &&\n            nodeClassName !== 'node node-finish' &&\n            nodeClassName !== 'node node-wall'\n          ) {\n            document.getElementById(`node-${node.row}-${node.col}`).className = 'node';\n            node.isVisited = false;\n            node.distance = Infinity;\n            node.distanceToFinishNode =\n              Math.abs(this.state.FINISH_NODE_ROW - node.row) + Math.abs(this.state.FINISH_NODE_COL - node.col);\n          }\n\n          if (nodeClassName === 'node node-finish') {\n            node.isVisited = false;\n            node.distance = Infinity;\n            node.distanceToFinishNode = 0;\n          }\n          \n          if (nodeClassName === 'node node-start') {\n            node.isVisited = false;\n            node.distance = Infinity;\n            node.distanceToFinishNode =\n              Math.abs(this.state.FINISH_NODE_ROW - node.row) + Math.abs(this.state.FINISH_NODE_COL - node.col);\n            node.isStart = true;\n            node.isWall = false;\n            node.previousNode = null;\n            node.isNode = true;\n          }\n        }\n      }\n    }\n  }\n\n  clearWalls = () => {\n    if (!this.state.isRunning) {\n      const newGrid = this.state.grid.slice();\n\n      for (const row of newGrid) {\n        for (const node of row) {\n          let nodeClassName = document.getElementById(`node-${node.row}-${node.col}`).className;\n\n          if (nodeClassName === 'node node-wall') {\n            document.getElementById(`node-${node.row}-${node.col}`).className = 'node';\n            node.isWall = false;\n          }\n        }\n      }\n    }\n  }\n\n  handleClear = () => {\n    this.clearGrid()\n    this.clearWalls()\n  }\n\n  visualize = (algo) => {\n    if (!this.state.isRunning) {\n      this.clearGrid();\n      this.toggleIsRunning();\n\n      const { grid } = this.state;\n      const startNode = grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\n      const finishNode = grid[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL];\n\n      let visitedNodesInOrder;\n      switch (algo) {\n        case 'Dijkstra':\n          visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n          break;\n        case 'BFS':\n          visitedNodesInOrder = bfs(grid, startNode, finishNode);\n          break;\n        case 'DFS':\n          visitedNodesInOrder = dfs(grid, startNode, finishNode);\n          break;\n        default:\n          break;\n      }\n\n      const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n      nodesInShortestPathOrder.push('end');\n      this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\n    }\n  }\n\n  animate = (visitedNodesInOrder, nodesInShortestPathOrder) => {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.animateShortestPath(nodesInShortestPathOrder);\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        const nodeClassName = document.getElementById(`node-${node.row}-${node.col}`).className;\n\n        if (nodeClassName !== 'node node-start' && nodeClassName !== 'node node-finish') {\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited';\n        }\n      }, 10 * i);\n    }\n  }\n\n\n  animateShortestPath = (nodesInShortestPathOrder) => {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      if (nodesInShortestPathOrder[i] === 'end') {\n        setTimeout(() => {\n          this.toggleIsRunning();\n        }, i * 50);\n      } else {\n        setTimeout(() => {\n          const node = nodesInShortestPathOrder[i];\n          const nodeClassName = document.getElementById(`node-${node.row}-${node.col}`).className;\n          if (nodeClassName !== 'node node-start' && nodeClassName !== 'node node-finish') {\n            document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-shortest-path';\n          }\n        }, i * 40);\n      }\n    }\n  }\n\n  render() {\n    const { grid, mousePressed } = this.state;\n    return (\n      <Wrapper>\n        <ChartWrapper onMouseLeave={() => this.handleMouseLeave()}>\n            {grid.map((row, rowIdx) => {\n              return (\n                <ChartRowWrapper key={rowIdx}>\n                  {row.map((node, nodeIdx) => {\n                    const { row, col, isFinish, isStart, isWall } = node;\n                    return (\n                      <Node\n                        key={nodeIdx}\n                        col={col}\n                        isFinish={isFinish}\n                        isStart={isStart}\n                        isWall={isWall}\n                        mousePressed={mousePressed}\n                        onMouseDown={(row, col) => this.handleMouseDown(row, col)}\n                        onMouseEnter={(row, col) => this.handleMouseEnter(row, col)}\n                        onMouseUp={() => this.handleMouseUp(row, col)}\n                        row={row}\n                      ></Node>\n                    );\n                  })}\n                  <br />\n                </ChartRowWrapper>\n              );\n            })}\n        </ChartWrapper>\n        <ButtonWrapper>\n          <Button variant='contained' style={ButtonStyle} onClick={() => this.handleClear()}>\n            Clear\n          </Button>\n          <Button variant='contained' style={ButtonStyle} onClick={() => this.visualize('BFS')}>\n            BFS\n          </Button>\n          <Button variant=\"contained\" style={ButtonStyle} onClick={() => this.visualize('DFS')}>\n            DFS\n          </Button>\n          <Button variant='contained' style={ButtonStyle} onClick={() => this.visualize('Dijkstra')}>\n            Dijkstra\n        </Button>\n        </ButtonWrapper>\n      </Wrapper>\n    );\n  }\n}\n\nconst getNewGridWithWallToggled = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  if (!node.isStart && !node.isFinish && node.isNode && !node.isWall) {\n    const newNode = {\n      ...node,\n      isWall: !node.isWall  ,\n    };\n    newGrid[row][col] = newNode;\n  }\n  return newGrid;\n};\n\n\nfunction getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n\nconst ButtonStyle = { width: '15%', height: '100%', margin: '1%' };\n\nconst Wrapper = styled.div`\n  width: 100vw;\n  height: 90%;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n`;\n\nconst ButtonWrapper = styled.div`\n  display: flex;\n  justify-content: center;\n  width: 100vw;\n  height: 8vh;\n  padding: 1.5vh;\n`;\n\nconst ChartWrapper = styled.div`\n  width: 80%;\n  height: 85%;\n  display: flex;\n  flex-direction: column;\n  justify-content: center; \n\n  padding: 1%;\n  border: 3px solid #5f5f5f;\n  border-radius: 10px;\n`;\n\nconst ChartRowWrapper = styled.div`\n  display: flex;\n  height: 4%;\n  \n`","// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-nocheck\n\nexport const bfs = (grid, startNode, finishNode) => {\n  let visitedNodesInOrder = [];\n  const nextNodesStack = [startNode];\n  while (nextNodesStack.length) {\n    const currentNode = nextNodesStack.shift();\n    if (currentNode === finishNode) return visitedNodesInOrder;\n\n    if (currentNode && !currentNode.isWall && (currentNode.isStart || !currentNode.isVisited)) {\n      currentNode.isVisited = true;\n      visitedNodesInOrder.push(currentNode);\n      const { col, row } = currentNode;\n      let nextNode;\n      if (row > 0) {\n        nextNode = grid[row - 1][col];\n        if (!nextNode.isVisited) {\n          nextNode.previousNode = currentNode;\n          nextNodesStack.push(nextNode);\n        }\n      }\n      if (row < grid.length - 1) {\n        nextNode = grid[row + 1][col];\n        if (!nextNode.isVisited) {\n          nextNode.previousNode = currentNode;\n          nextNodesStack.push(nextNode);\n        }\n      }\n      if (col > 0) {\n        nextNode = grid[row][col - 1];\n        if (!nextNode.isVisited) {\n          nextNode.previousNode = currentNode;\n          nextNodesStack.push(nextNode);\n        }\n      }\n      if (col < grid[0].length - 1) {\n        nextNode = grid[row][col + 1];\n        if (!nextNode.isVisited) {\n          nextNode.previousNode = currentNode;\n          nextNodesStack.push(nextNode);\n        }\n      }\n    }\n  }\n}\n","import styled from 'styled-components';\n\ninterface BarProps {\n  width: number;\n  height: number;\n  IsSorted: boolean;\n  IsSearched: boolean;\n  IsSelected: boolean;\n  IsSwaped: boolean;\n}\n\nconst Bar = ({ width, height, IsSorted, IsSearched, IsSelected, IsSwaped }: BarProps): JSX.Element => {\n  let color = '#5f5f5f';\n  if (IsSwaped) {\n    //magenta\n    color = '#D81159';\n    //E54F6D\n  } else if (IsSelected) {\n    //yellow\n    color = '#FFD166';\n    //FA7921\n  } else if (IsSearched) {\n    //blue\n    //#064789, 1C5D99, 448FA3, 68C5DB\n    color = '#118AB2';\n  } else if (IsSorted) {\n    //green\n    color = '#06D6A0';\n    //379392, 1D7874, 49A078, 049A8F\n  }\n\n  return <Wrapper $width={width} $height={height} $color={color}></Wrapper>;\n};\n\ninterface WrapperProps {\n  $width: number;\n  $height: number;\n  $color: string;\n}\n\nconst Wrapper = styled.div.attrs(({ $width, $height, $color }: WrapperProps) => ({\n  style: {\n    width: `${$width}%`,\n    height: `${$height}%`,\n    background: $color,\n  },\n}))<WrapperProps>`\n  border: 0.1px solid white;\n`;\n\nexport default Bar;\n","import styled from 'styled-components';\nimport { Trace } from '../algorithms/helper';\nimport Bar from './Bar';\n\nconst genBarGraph = ({ array, sortedIndices, searched, selected, swaped }: Trace) => {\n  return array.map((num, idx) => {\n    const width = 100 / array.length;\n    const height = (num / 1000) * 100;\n    const IsSorted = sortedIndices.includes(idx);\n    const IsSearched = searched.includes(idx);\n    const IsSelected = selected.includes(idx);\n    const IsSwaped = swaped.includes(idx);\n    return (\n      <Bar\n        key={`${idx}_${num}`}\n        width={width}\n        height={height}\n        IsSorted={IsSorted}\n        IsSearched={IsSearched}\n        IsSelected={IsSelected}\n        IsSwaped={IsSwaped}\n      ></Bar>\n    );\n  });\n};\n\nconst SortChart = ({ array, sortedIndices, searched, selected, swaped }: Trace): JSX.Element => {\n  return <Wrapper>{genBarGraph({ array, sortedIndices, searched, selected, swaped })}</Wrapper>;\n};\n\nconst Wrapper = styled.div`\n  display: flex;\n  justify-content: center;\n  align-items: flex-end;\n  width: 100%;\n  height: 100%;\n  background: white;\n`;\n\nexport default SortChart;\n","import { TraceArray, Trace } from '../algorithms/helper';\nimport { useEffect, useRef, useState } from 'react';\nimport styled from 'styled-components';\nimport SortChart from './SortChart';\nimport { Button } from '@material-ui/core';\n\ninterface SortingVisualizerProps {\n  array: number[];\n  traces: TraceArray;\n}\n\nfunction SortingVisualizer(props: SortingVisualizerProps): JSX.Element {\n  const [visualState, setVisualState] = useState<Trace>({\n    array: [],\n    sortedIndices: [],\n    searched: [],\n    selected: [],\n    swaped: [],\n  });\n  const [traces, setTraces] = useState<TraceArray>([]);\n  const [timeoutIds, setTimeoutIds] = useState<NodeJS.Timeout[]>([]);\n  const isPlaying = useRef<boolean>(false);\n\n  useEffect(() => {\n    if (visualState.array !== props.array) {\n      console.log('reset array');\n      _reset(props.array);\n    }\n\n    if (traces !== props.traces) {\n      console.log('reset trace');\n      setTraces(props.traces);\n    }\n    isPlaying.current = false;\n    clearTimeouts();\n  }, [props.array, props.traces]);\n\n  const clearTimeouts = () => {\n    timeoutIds.forEach((timeout) => {\n      clearTimeout(timeout);\n    });\n    isPlaying.current = false;\n    setTimeoutIds([]);\n  };\n\n  const _reset = (array: number[]) => {\n    setVisualState({\n      array,\n      sortedIndices: [],\n      searched: [],\n      selected: [],\n      swaped: [],\n    });\n  };\n\n  const _changeVisualState = (trace: Trace) => {\n    setVisualState({\n      array: trace.array,\n      sortedIndices: trace.sortedIndices,\n      searched: trace.searched,\n      selected: trace.selected,\n      swaped: trace.swaped,\n    });\n  };\n\n  const run = () => {\n    if (isPlaying.current == false) {\n      isPlaying.current = true;\n      console.log('set playing', isPlaying.current);\n      const timeoutArray: NodeJS.Timeout[] = [];\n      const timer = 30;\n\n      traces.forEach((trace, i) => {\n        const timeoutId = setTimeout(\n          (item) => {\n            _changeVisualState(item);\n          },\n          i * timer,\n          trace,\n        );\n\n        timeoutArray.push(timeoutId);\n      });\n\n      const timeoutId = setTimeout(clearTimeouts, traces.length * timer);\n      timeoutArray.push(timeoutId);\n      setTimeoutIds(timeoutArray);\n    } else {\n      console.log('already playing');\n    }\n  };\n\n  const reset = () => {\n    isPlaying.current = false;\n    clearTimeouts();\n    _reset(visualState.array);\n  };\n\n  return (\n    <Wrapper>\n      <ChartWrapper>\n        <SortChart\n          array={visualState.array}\n          sortedIndices={visualState.sortedIndices}\n          searched={visualState.searched}\n          selected={visualState.selected}\n          swaped={visualState.swaped}\n        />\n      </ChartWrapper>\n      <ButtonWrapper>\n        <Button variant=\"contained\" onClick={run} style={ButtonStyle}>\n          <span>Run</span>\n        </Button>\n        <Button variant=\"contained\" onClick={reset} style={ButtonStyle}>\n          <span>Stop</span>\n        </Button>\n      </ButtonWrapper>\n    </Wrapper>\n  );\n}\n\nconst ButtonStyle = { width: '10%', height: '100%', margin: '1%' };\n\nconst Wrapper = styled.div`\n  width: 100vw;\n  height: 70%;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n`;\n\nconst ButtonWrapper = styled.div`\n  display: flex;\n  justify-content: center;\n  width: 100vw;\n  height: 8vh;\n  padding: 1.5vh;\n`;\n\nconst ChartWrapper = styled.div`\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  width: 95%;\n  height: 90%;\n\n  background: white;\n  padding: 1%;\n  border: 3px solid #5f5f5f;\n  border-radius: 10px;\n`;\n\nexport default SortingVisualizer;\n","import { useEffect, useState } from 'react';\nimport styled from 'styled-components';\nimport { BubbleSort } from '../algorithms/BubbleSort';\nimport { TraceArray } from '../algorithms/helper';\nimport { InsertionSort } from '../algorithms/InsertionSort';\nimport { MergeSort } from '../algorithms/MergeSort';\nimport { QuickSort } from '../algorithms/QuickSort';\nimport { SelectionSort } from '../algorithms/SelectionSort';\nimport Caption from './Caption';\nimport Navbar from './Navbar';\nimport PathfindingVisualizer from './PathfindingVisualizer/PathfindingVisualizer';\nimport SortingVisualizer from './SortingVisualizer';\n\ninterface Algorithms {\n  [name: string]: (arr: number[]) => TraceArray;\n}\nexport type AlgorithmTypes = 'Selection Sort' | 'Bubble Sort' | 'Insertion Sort' | 'Merge Sort' | 'Quick Sort';\n\nfunction AlgorithmVisualizer(): JSX.Element {\n  const [isSorting, setIsSorting] = useState<boolean>(true);\n  const [array, setArray] = useState<number[]>([]);\n  const [arrayLength, setArrayLength] = useState<number>(100);\n  const [traces, setTraces] = useState<TraceArray>([]);\n  const [algorithm, setAlgorithm] = useState<AlgorithmTypes>('Selection Sort');\n\n  const ALGORITHMS: Algorithms = {\n    'Selection Sort': SelectionSort,\n    'Bubble Sort': BubbleSort,\n    'Insertion Sort': InsertionSort,\n    'Merge Sort': MergeSort,\n    'Quick Sort': QuickSort,\n  };\n\n  const resetArray = (arrayLength: number) => {\n    const max = 1000;\n    const min = 10;\n    setTraces([]);\n    console.log('set trace to []');\n    setArray([...Array(arrayLength)].map(() => Math.floor(Math.random() * (max - min + 1)) + min));\n  };\n\n  const handleSetAlgorithm = (name: AlgorithmTypes) => {\n    setAlgorithm(name);\n  };\n\n  const handleSetArrayLength = (arrayLength: number) => {\n    setArrayLength(arrayLength);\n  };\n\n  const handleResetArray = () => {\n    resetArray(arrayLength);\n  };\n\n  const handleToggleVisualizer = () => {\n    setIsSorting(!isSorting);\n  };\n\n  const createTraces = () => {\n    const sort = ALGORITHMS[algorithm];\n\n    if (sort) {\n      const sorted = sort([...array]);\n      setTraces(sorted);\n      console.log('create trace');\n    }\n  };\n\n  useEffect(() => {\n    setTraces([]);\n    console.log('algo changed, resetting the traces');\n    createTraces();\n  }, [algorithm]);\n\n  useEffect(() => {\n    resetArray(arrayLength);\n  }, [arrayLength]);\n\n  useEffect(() => {\n    createTraces();\n  }, [array]);\n\n  return (\n    <Wrapper>\n      <Navbar\n        handleResetArray={handleResetArray}\n        handleSetAlgorithm={handleSetAlgorithm}\n        handleSetArrayLengh={handleSetArrayLength}\n        handleToggleVisualizer={handleToggleVisualizer}\n        isSorting={isSorting}\n      />\n      {isSorting === true ? (\n        <>\n          <SortingVisualizer array={array} traces={traces} />\n          <Caption selectedAlgorithm={algorithm} />{' '}\n        </>\n      ) : (\n        <PathfindingVisualizer />\n      )}\n    </Wrapper>\n  );\n}\n\nconst Wrapper = styled.div`\n  display: flex;\n  flex-direction: column;\n  justify-content: flex-start;\n  align-items: center;\n  width: 100vw;\n  height: 100vh;\n  background: white;\n`;\n\nexport default AlgorithmVisualizer;\n","import AlgorithmVisualizer from './components/AlgorithmVisualizer';\n\nfunction App(): JSX.Element {\n  return <AlgorithmVisualizer />;\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler): void => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import { createGlobalStyle } from 'styled-components';\nimport normalize from 'styled-normalize';\n\nconst GlobalStyle = createGlobalStyle`\n  ${normalize};\n  html {\n    overflow-x: hidden;\n  }\n  \n  * {\n    margin: 0;\n    box-sizing: border-box;\n    font-size: 2vw;\n    font-family: 'Roboto', sans-serif;\n  }\n  h2, h3, li, p, a, button, span {\n    font-family: 'Roboto', sans-serif;\n    letter-spacing: -0.05rem;\n  }\n  ul, li {\n    margin: 0;\n    padding: 0;\n    list-style: none;\n  }\n  \n  button {\n    cursor: pointer;\n    outline: none;\n  }\n  a {\n    text-decoration: none;\n  }\n\n`;\n\nexport default GlobalStyle;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\nimport GlobalStyle from './GlobalStyle';\n\nReactDOM.render(\n  <React.StrictMode>\n    <GlobalStyle />\n    <App />\n    <GlobalStyle />\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}